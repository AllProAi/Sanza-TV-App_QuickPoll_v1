<!-- Generated by SpecStory -->

# Task 11 Completion and Markdown Update (2025-05-18 05:30:32)

_**User**_

@TASK-011.md 

Complete task 11 then update md file as instructed. 

---

_**Assistant**_



---

Let me check the project structure first to understand what we're working with.

---

<details>
            <summary>Listed current directory • **8** results</summary>
        
| Name |
|-------|
| 📁 `tasks` |
| 📁 `StreamVibe` |
| 📄 `TASK-LIST.md` |
| 📁 `docs` |
| 📄 `README.md` |
| 📄 `TASK-TEMPLATE.md` |
| 📄 `.cursorindexingignore` |
| 📁 `.specstory` |

</details>

---

Let's see what's in the StreamVibe directory, which is likely our main app directory:

---

<details>
            <summary>Listed directory StreamVibe • **13** results</summary>
        
| Name |
|-------|
| 📁 `src` |
| 📄 `vite.config.ts` |
| 📄 `index.html` |
| 📁 `node_modules` |
| 📄 `pnpm-lock.yaml` |
| 📁 `public` |
| 📄 `package.json` |
| 📄 `README.md` |
| 📄 `tsconfig.app.json` |
| 📄 `tsconfig.node.json` |
| 📄 `tsconfig.json` |
| 📄 `eslint.config.js` |
| 📄 `.gitignore` |

</details>

---

Now, let's look at the src directory to see the current structure:

---

<details>
            <summary>Listed directory StreamVibe/src • **15** results</summary>
        
| Name |
|-------|
| 📁 `utils` |
| 📁 `hooks` |
| 📄 `App.tsx` |
| 📁 `pages` |
| 📁 `navigation` |
| 📁 `services` |
| 📁 `types` |
| 📁 `styles` |
| 📁 `context` |
| 📄 `main.tsx` |
| 📁 `components` |
| 📁 `assets` |
| 📄 `vite-env.d.ts` |
| 📄 `index.css` |
| 📄 `App.css` |

</details>

---

Let me check if there are any context files already created:

---

<details>
            <summary>Listed directory StreamVibe/src/context • **1** results</summary>
        
| Name |
|-------|
| 📄 `NavigationContext.tsx` |

</details>

---

Let's also check the hooks directory to see what hooks are already implemented:

---

<details>
            <summary>Listed directory StreamVibe/src/hooks • **2** results</summary>
        
| Name |
|-------|
| 📄 `useKeyboardNavigation.ts` |
| 📄 `useFocus.ts` |

</details>

---

Let's look at the NavigationContext to understand how the existing context is structured:

---

Read file: StreamVibe/src/context/NavigationContext.tsx

---

Now let's check the package.json to understand the available dependencies:

---

Read file: StreamVibe/package.json

---

Let's examine the App.tsx file to understand how we should integrate our context providers:

---

Read file: StreamVibe/src/App.tsx

---

Let's check the main.tsx file to understand the entry point of the application:

---

Read file: StreamVibe/src/main.tsx

---

Let's look at the AppLayout component since it might be a good place to understand the component hierarchy:

---

<details>
            <summary>Grep search for "AppLayout" • **2** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///d%3A/Sanza-TV-App_QuickPoll_v1/StreamVibe/src/components/layout/AppLayout.tsx` | L4 | `interface AppLayoutProps {` |
| `file:///d%3A/Sanza-TV-App_QuickPoll_v1/StreamVibe/src/components/layout/AppLayout.tsx` | L24 | `const AppLayout: React.FC<AppLayoutProps> = ({ children, initialFocus }) => {` |
| `file:///d%3A/Sanza-TV-App_QuickPoll_v1/StreamVibe/src/components/layout/AppLayout.tsx` | L36 | `export default AppLayout;` |
| `file:///d%3A/Sanza-TV-App_QuickPoll_v1/StreamVibe/src/App.tsx` | L3 | `import AppLayout from './components/layout/AppLayout';` |
| `file:///d%3A/Sanza-TV-App_QuickPoll_v1/StreamVibe/src/App.tsx` | L70 | `<AppLayout initialFocus="browse-button">` |
| `file:///d%3A/Sanza-TV-App_QuickPoll_v1/StreamVibe/src/App.tsx` | L80 | `</AppLayout>` |

</details>

---

Let's examine the AppLayout component:

---

Read file: StreamVibe/src/components/layout/AppLayout.tsx

---

Now I have a good understanding of the current project structure. Based on this exploration, I'll now implement the required context providers for TASK-011. Here's my implementation plan:

1. Create AppContext.tsx - The main application context
2. Create ContentContext.tsx - For content management
3. Create UserContext.tsx - For user preferences
4. Create PlayerContext.tsx - For video player state
5. Create hooks for each context
6. Integrate the context providers in the main application

Let's start implementing these files:

---

```diff
- 
+ import React, { createContext, useContext, useReducer, useEffect, ReactNode } from 'react';
+ 
+ // Define types for the app state
+ export interface AppState {
+   isLoading: boolean;
+   darkMode: boolean;
+   isOnline: boolean;
+   lastUpdated: string;
+   isDebugMode: boolean;
+ }
+ 
+ // Define action types
+ type AppAction =
+   | { type: 'SET_LOADING'; payload: boolean }
+   | { type: 'TOGGLE_DARK_MODE' }
+   | { type: 'SET_DARK_MODE'; payload: boolean }
+   | { type: 'SET_ONLINE_STATUS'; payload: boolean }
+   | { type: 'SET_DEBUG_MODE'; payload: boolean };
+ 
+ // Define the initial state
+ const initialState: AppState = {
+   isLoading: false,
+   darkMode: true, // Default to dark mode for TV interface
+   isOnline: true,
+   lastUpdated: new Date().toISOString(),
+   isDebugMode: false,
+ };
+ 
+ // Create the context with a default value
+ interface AppContextType {
+   state: AppState;
+   dispatch: React.Dispatch<AppAction>;
+   toggleDarkMode: () => void;
+   setLoading: (loading: boolean) => void;
+   setDebugMode: (enabled: boolean) => void;
+ }
+ 
+ const AppContext = createContext<AppContextType>({
+   state: initialState,
+   dispatch: () => null,
+   toggleDarkMode: () => null,
+   setLoading: () => null,
+   setDebugMode: () => null,
+ });
+ 
+ // Create a reducer function to handle state updates
+ const appReducer = (state: AppState, action: AppAction): AppState => {
+   switch (action.type) {
+     case 'SET_LOADING':
+       return { ...state, isLoading: action.payload, lastUpdated: new Date().toISOString() };
+     case 'TOGGLE_DARK_MODE':
+       return { ...state, darkMode: !state.darkMode, lastUpdated: new Date().toISOString() };
+     case 'SET_DARK_MODE':
+       return { ...state, darkMode: action.payload, lastUpdated: new Date().toISOString() };
+     case 'SET_ONLINE_STATUS':
+       return { ...state, isOnline: action.payload, lastUpdated: new Date().toISOString() };
+     case 'SET_DEBUG_MODE':
+       return { ...state, isDebugMode: action.payload, lastUpdated: new Date().toISOString() };
+     default:
+       return state;
+   }
+ };
+ 
+ // Create the AppProvider component
+ interface AppProviderProps {
+   children: ReactNode;
+ }
+ 
+ export const AppProvider: React.FC<AppProviderProps> = ({ children }) => {
+   // Use reducer to manage state
+   const [state, dispatch] = useReducer(appReducer, initialState, () => {
+     // Load persisted state from localStorage if available
+     const persistedState = localStorage.getItem('appState');
+     return persistedState ? { ...initialState, ...JSON.parse(persistedState) } : initialState;
+   });
+ 
+   // Create memoized action creators
+   const toggleDarkMode = React.useCallback(() => {
+     dispatch({ type: 'TOGGLE_DARK_MODE' });
+   }, []);
+ 
+   const setLoading = React.useCallback((loading: boolean) => {
+     dispatch({ type: 'SET_LOADING', payload: loading });
+   }, []);
+ 
+   const setDebugMode = React.useCallback((enabled: boolean) => {
+     dispatch({ type: 'SET_DEBUG_MODE', payload: enabled });
+   }, []);
+ 
+   // Monitor online status
+   useEffect(() => {
+     const handleOnlineStatusChange = () => {
+       dispatch({ type: 'SET_ONLINE_STATUS', payload: navigator.onLine });
+     };
+ 
+     window.addEventListener('online', handleOnlineStatusChange);
+     window.addEventListener('offline', handleOnlineStatusChange);
+ 
+     return () => {
+       window.removeEventListener('online', handleOnlineStatusChange);
+       window.removeEventListener('offline', handleOnlineStatusChange);
+     };
+   }, []);
+ 
+   // Persist state changes to localStorage
+   useEffect(() => {
+     localStorage.setItem('appState', JSON.stringify({
+       darkMode: state.darkMode,
+       isDebugMode: state.isDebugMode,
+     }));
+   }, [state.darkMode, state.isDebugMode]);
+ 
+   // Provide the context value
+   const contextValue: AppContextType = {
+     state,
+     dispatch,
+     toggleDarkMode,
+     setLoading,
+     setDebugMode,
+   };
+ 
+   return (
+     <AppContext.Provider value={contextValue}>
+       {children}
+     </AppContext.Provider>
+   );
+ };
+ 
+ // Create a custom hook for using the context
+ export const useAppContext = () => useContext(AppContext); 
```

---

Let's fix the linter error in the AppContext.tsx file:

---

```diff
- import React, { createContext, useContext, useReducer, useEffect, ReactNode } from 'react';
+ import React, { createContext, useContext, useReducer, useEffect } from 'react';
+ import type { ReactNode } from 'react';
  
  // Define types for the app state
```

---

Now let's create the ContentContext:

---

```diff
- 
+ import React, { createContext, useContext, useReducer, useEffect } from 'react';
+ import type { ReactNode } from 'react';
+ 
+ // Define content-related types
+ export interface ContentItem {
+   id: string;
+   title: string;
+   description: string;
+   posterUrl: string;
+   thumbnailUrl: string;
+   type: 'movie' | 'show' | 'live';
+   genre: string[];
+   releaseYear?: number;
+   duration?: number;
+   rating?: number;
+   isFavorite: boolean;
+   progress?: number;
+ }
+ 
+ export interface Category {
+   id: string;
+   name: string;
+   items: string[]; // References to content item IDs
+ }
+ 
+ export interface ContentState {
+   items: Record<string, ContentItem>;
+   categories: Record<string, Category>;
+   featuredContent: string[];
+   recentlyWatched: string[];
+   favorites: string[];
+   isLoading: boolean;
+   error: string | null;
+ }
+ 
+ // Define action types
+ type ContentAction =
+   | { type: 'FETCH_CONTENT_START' }
+   | { type: 'FETCH_CONTENT_SUCCESS'; payload: { items: Record<string, ContentItem>, categories: Record<string, Category> } }
+   | { type: 'FETCH_CONTENT_ERROR'; payload: string }
+   | { type: 'ADD_TO_FAVORITES'; payload: string }
+   | { type: 'REMOVE_FROM_FAVORITES'; payload: string }
+   | { type: 'UPDATE_PROGRESS'; payload: { id: string; progress: number } }
+   | { type: 'ADD_TO_RECENTLY_WATCHED'; payload: string }
+   | { type: 'SET_FEATURED_CONTENT'; payload: string[] };
+ 
+ // Define initial state
+ const initialState: ContentState = {
+   items: {},
+   categories: {},
+   featuredContent: [],
+   recentlyWatched: [],
+   favorites: [],
+   isLoading: false,
+   error: null,
+ };
+ 
+ // Create context
+ interface ContentContextType {
+   state: ContentState;
+   dispatch: React.Dispatch<ContentAction>;
+   fetchContent: () => Promise<void>;
+   toggleFavorite: (contentId: string) => void;
+   updateProgress: (contentId: string, progress: number) => void;
+   markAsWatched: (contentId: string) => void;
+ }
+ 
+ const ContentContext = createContext<ContentContextType>({
+   state: initialState,
+   dispatch: () => null,
+   fetchContent: async () => {},
+   toggleFavorite: () => {},
+   updateProgress: () => {},
+   markAsWatched: () => {},
+ });
+ 
+ // Create reducer
+ const contentReducer = (state: ContentState, action: ContentAction): ContentState => {
+   switch (action.type) {
+     case 'FETCH_CONTENT_START':
+       return {
+         ...state,
+         isLoading: true,
+         error: null,
+       };
+     case 'FETCH_CONTENT_SUCCESS':
+       return {
+         ...state,
+         items: action.payload.items,
+         categories: action.payload.categories,
+         isLoading: false,
+       };
+     case 'FETCH_CONTENT_ERROR':
+       return {
+         ...state,
+         isLoading: false,
+         error: action.payload,
+       };
+     case 'ADD_TO_FAVORITES': {
+       const updatedItems = { ...state.items };
+       if (updatedItems[action.payload]) {
+         updatedItems[action.payload] = {
+           ...updatedItems[action.payload],
+           isFavorite: true,
+         };
+       }
+       return {
+         ...state,
+         items: updatedItems,
+         favorites: [...state.favorites, action.payload],
+       };
+     }
+     case 'REMOVE_FROM_FAVORITES': {
+       const updatedItems = { ...state.items };
+       if (updatedItems[action.payload]) {
+         updatedItems[action.payload] = {
+           ...updatedItems[action.payload],
+           isFavorite: false,
+         };
+       }
+       return {
+         ...state,
+         items: updatedItems,
+         favorites: state.favorites.filter(id => id !== action.payload),
+       };
+     }
+     case 'UPDATE_PROGRESS': {
+       const { id, progress } = action.payload;
+       const updatedItems = { ...state.items };
+       if (updatedItems[id]) {
+         updatedItems[id] = {
+           ...updatedItems[id],
+           progress,
+         };
+       }
+       return {
+         ...state,
+         items: updatedItems,
+       };
+     }
+     case 'ADD_TO_RECENTLY_WATCHED': {
+       const recentlyWatched = [
+         action.payload,
+         ...state.recentlyWatched.filter(id => id !== action.payload),
+       ].slice(0, 20); // Limit to 20 items
+       
+       return {
+         ...state,
+         recentlyWatched,
+       };
+     }
+     case 'SET_FEATURED_CONTENT':
+       return {
+         ...state,
+         featuredContent: action.payload,
+       };
+     default:
+       return state;
+   }
+ };
+ 
+ // Create provider
+ interface ContentProviderProps {
+   children: ReactNode;
+ }
+ 
+ export const ContentProvider: React.FC<ContentProviderProps> = ({ children }) => {
+   const [state, dispatch] = useReducer(contentReducer, initialState, () => {
+     // Load persisted favorites and recently watched from localStorage
+     const persistedData = localStorage.getItem('contentState');
+     if (persistedData) {
+       const parsedData = JSON.parse(persistedData);
+       return {
+         ...initialState,
+         favorites: parsedData.favorites || [],
+         recentlyWatched: parsedData.recentlyWatched || [],
+       };
+     }
+     return initialState;
+   });
+ 
+   // Example function to fetch content (would connect to an API in a real app)
+   const fetchContent = React.useCallback(async () => {
+     dispatch({ type: 'FETCH_CONTENT_START' });
+     try {
+       // Simulate API call with timeout
+       // In a real application, this would be a fetch request to your API
+       const mockFetch = new Promise<{ items: Record<string, ContentItem>, categories: Record<string, Category> }>(resolve => {
+         setTimeout(() => {
+           // Mock data structure
+           resolve({
+             items: {
+               // Mock items would go here
+             },
+             categories: {
+               // Mock categories would go here
+             }
+           });
+         }, 1000);
+       });
+ 
+       const data = await mockFetch;
+       dispatch({ type: 'FETCH_CONTENT_SUCCESS', payload: data });
+     } catch (error) {
+       dispatch({ type: 'FETCH_CONTENT_ERROR', payload: (error as Error).message });
+     }
+   }, []);
+ 
+   // Toggle favorite status for a content item
+   const toggleFavorite = React.useCallback((contentId: string) => {
+     if (state.favorites.includes(contentId)) {
+       dispatch({ type: 'REMOVE_FROM_FAVORITES', payload: contentId });
+     } else {
+       dispatch({ type: 'ADD_TO_FAVORITES', payload: contentId });
+     }
+   }, [state.favorites]);
+ 
+   // Update progress for a content item
+   const updateProgress = React.useCallback((contentId: string, progress: number) => {
+     dispatch({ type: 'UPDATE_PROGRESS', payload: { id: contentId, progress } });
+     dispatch({ type: 'ADD_TO_RECENTLY_WATCHED', payload: contentId });
+   }, []);
+ 
+   // Mark content as watched (add to recently watched)
+   const markAsWatched = React.useCallback((contentId: string) => {
+     dispatch({ type: 'ADD_TO_RECENTLY_WATCHED', payload: contentId });
+   }, []);
+ 
+   // Persist favorites and recently watched to localStorage
+   useEffect(() => {
+     localStorage.setItem('contentState', JSON.stringify({
+       favorites: state.favorites,
+       recentlyWatched: state.recentlyWatched,
+     }));
+   }, [state.favorites, state.recentlyWatched]);
+ 
+   // Context value
+   const contextValue: ContentContextType = {
+     state,
+     dispatch,
+     fetchContent,
+     toggleFavorite,
+     updateProgress,
+     markAsWatched,
+   };
+ 
+   return (
+     <ContentContext.Provider value={contextValue}>
+       {children}
+     </ContentContext.Provider>
+   );
+ };
+ 
+ export const useContentContext = () => useContext(ContentContext); 
```

---

Let's create the UserContext next:

---

```diff
- 
+ import React, { createContext, useContext, useReducer, useEffect } from 'react';
+ import type { ReactNode } from 'react';
+ 
+ // Define user-related types
+ export interface UserProfile {
+   id: string;
+   name: string;
+   avatarUrl?: string;
+   parentalControlLevel?: 'kids' | 'teen' | 'adult' | 'all';
+   language: string;
+   subtitle: string;
+   audioOutput: 'stereo' | 'surround' | 'dolby';
+   streamingQuality: 'auto' | 'low' | 'medium' | 'high' | '4k';
+   autoplay: boolean;
+ }
+ 
+ export interface UserState {
+   profiles: UserProfile[];
+   activeProfileId: string | null;
+   isAuthenticated: boolean;
+   isLoading: boolean;
+   error: string | null;
+ }
+ 
+ // Define action types
+ type UserAction =
+   | { type: 'LOGIN_START' }
+   | { type: 'LOGIN_SUCCESS'; payload: { profiles: UserProfile[]; activeProfileId: string } }
+   | { type: 'LOGIN_ERROR'; payload: string }
+   | { type: 'LOGOUT' }
+   | { type: 'SWITCH_PROFILE'; payload: string }
+   | { type: 'UPDATE_PROFILE'; payload: UserProfile }
+   | { type: 'ADD_PROFILE'; payload: UserProfile }
+   | { type: 'REMOVE_PROFILE'; payload: string }
+   | { type: 'SET_USER_PREFERENCE'; payload: { profileId: string; key: keyof UserProfile; value: any } };
+ 
+ // Define initial state
+ const initialState: UserState = {
+   profiles: [],
+   activeProfileId: null,
+   isAuthenticated: false,
+   isLoading: false,
+   error: null
+ };
+ 
+ // Create context
+ interface UserContextType {
+   state: UserState;
+   dispatch: React.Dispatch<UserAction>;
+   login: (username: string, password: string) => Promise<void>;
+   logout: () => void;
+   switchProfile: (profileId: string) => void;
+   updateProfile: (profile: UserProfile) => void;
+   setPreference: <K extends keyof UserProfile>(key: K, value: UserProfile[K]) => void;
+   getActiveProfile: () => UserProfile | null;
+ }
+ 
+ const UserContext = createContext<UserContextType>({
+   state: initialState,
+   dispatch: () => null,
+   login: async () => {},
+   logout: () => {},
+   switchProfile: () => {},
+   updateProfile: () => {},
+   setPreference: () => {},
+   getActiveProfile: () => null
+ });
+ 
+ // Create reducer
+ const userReducer = (state: UserState, action: UserAction): UserState => {
+   switch (action.type) {
+     case 'LOGIN_START':
+       return {
+         ...state,
+         isLoading: true,
+         error: null
+       };
+     case 'LOGIN_SUCCESS':
+       return {
+         ...state,
+         isLoading: false,
+         isAuthenticated: true,
+         profiles: action.payload.profiles,
+         activeProfileId: action.payload.activeProfileId
+       };
+     case 'LOGIN_ERROR':
+       return {
+         ...state,
+         isLoading: false,
+         error: action.payload
+       };
+     case 'LOGOUT':
+       return {
+         ...initialState
+       };
+     case 'SWITCH_PROFILE':
+       return {
+         ...state,
+         activeProfileId: action.payload
+       };
+     case 'UPDATE_PROFILE': {
+       const updatedProfiles = state.profiles.map(profile => 
+         profile.id === action.payload.id ? action.payload : profile
+       );
+       return {
+         ...state,
+         profiles: updatedProfiles
+       };
+     }
+     case 'ADD_PROFILE':
+       return {
+         ...state,
+         profiles: [...state.profiles, action.payload]
+       };
+     case 'REMOVE_PROFILE': {
+       const filteredProfiles = state.profiles.filter(profile => profile.id !== action.payload);
+       return {
+         ...state,
+         profiles: filteredProfiles,
+         activeProfileId: state.activeProfileId === action.payload
+           ? (filteredProfiles[0]?.id || null)
+           : state.activeProfileId
+       };
+     }
+     case 'SET_USER_PREFERENCE': {
+       const { profileId, key, value } = action.payload;
+       const updatedProfiles = state.profiles.map(profile => {
+         if (profile.id === profileId) {
+           return {
+             ...profile,
+             [key]: value
+           };
+         }
+         return profile;
+       });
+       return {
+         ...state,
+         profiles: updatedProfiles
+       };
+     }
+     default:
+       return state;
+   }
+ };
+ 
+ // Create provider
+ interface UserProviderProps {
+   children: ReactNode;
+ }
+ 
+ export const UserProvider: React.FC<UserProviderProps> = ({ children }) => {
+   const [state, dispatch] = useReducer(userReducer, initialState, () => {
+     // Load user state from localStorage
+     const savedUserState = localStorage.getItem('userState');
+     if (savedUserState) {
+       try {
+         return JSON.parse(savedUserState) as UserState;
+       } catch (e) {
+         console.error('Failed to parse saved user state', e);
+       }
+     }
+     return initialState;
+   });
+ 
+   // Login function (mock implementation)
+   const login = React.useCallback(async (username: string, password: string) => {
+     dispatch({ type: 'LOGIN_START' });
+     try {
+       // Simulate API call with timeout
+       await new Promise(resolve => setTimeout(resolve, 1000));
+       
+       // Mock successful login with sample profiles
+       const mockProfiles: UserProfile[] = [
+         {
+           id: '1',
+           name: 'Primary User',
+           language: 'en',
+           subtitle: 'en',
+           audioOutput: 'stereo',
+           streamingQuality: 'auto',
+           autoplay: true
+         }
+       ];
+       
+       dispatch({ 
+         type: 'LOGIN_SUCCESS', 
+         payload: { 
+           profiles: mockProfiles, 
+           activeProfileId: mockProfiles[0].id 
+         } 
+       });
+     } catch (error) {
+       dispatch({ 
+         type: 'LOGIN_ERROR', 
+         payload: (error as Error).message || 'Login failed' 
+       });
+     }
+   }, []);
+ 
+   // Logout function
+   const logout = React.useCallback(() => {
+     dispatch({ type: 'LOGOUT' });
+   }, []);
+ 
+   // Switch profile
+   const switchProfile = React.useCallback((profileId: string) => {
+     dispatch({ type: 'SWITCH_PROFILE', payload: profileId });
+   }, []);
+ 
+   // Update profile
+   const updateProfile = React.useCallback((profile: UserProfile) => {
+     dispatch({ type: 'UPDATE_PROFILE', payload: profile });
+   }, []);
+ 
+   // Set preference for active profile
+   const setPreference = React.useCallback(<K extends keyof UserProfile>(key: K, value: UserProfile[K]) => {
+     if (state.activeProfileId) {
+       dispatch({ 
+         type: 'SET_USER_PREFERENCE', 
+         payload: { 
+           profileId: state.activeProfileId, 
+           key, 
+           value 
+         } 
+       });
+     }
+   }, [state.activeProfileId]);
+ 
+   // Get active profile
+   const getActiveProfile = React.useCallback(() => {
+     if (!state.activeProfileId) return null;
+     return state.profiles.find(profile => profile.id === state.activeProfileId) || null;
+   }, [state.profiles, state.activeProfileId]);
+ 
+   // Persist state to localStorage
+   useEffect(() => {
+     if (state.isAuthenticated) {
+       localStorage.setItem('userState', JSON.stringify(state));
+     }
+   }, [state]);
+ 
+   // Context value
+   const contextValue: UserContextType = {
+     state,
+     dispatch,
+     login,
+     logout,
+     switchProfile,
+     updateProfile,
+     setPreference,
+     getActiveProfile
+   };
+ 
+   return (
+     <UserContext.Provider value={contextValue}>
+       {children}
+     </UserContext.Provider>
+   );
+ };
+ 
+ export const useUserContext = () => useContext(UserContext); 
```

---

Now let's create the PlayerContext for video playback:

---

```diff
- 
+ import React, { createContext, useContext, useReducer, useCallback, useRef, useEffect } from 'react';
+ import type { ReactNode } from 'react';
+ 
+ // Define player-related types
+ export interface PlayerState {
+   currentContentId: string | null;
+   isPlaying: boolean;
+   duration: number;
+   currentTime: number;
+   buffered: number;
+   volume: number;
+   isMuted: boolean;
+   playbackRate: number;
+   isFullscreen: boolean;
+   quality: 'auto' | '240p' | '360p' | '480p' | '720p' | '1080p' | '4k';
+   isLoading: boolean;
+   error: string | null;
+ }
+ 
+ // Define action types
+ type PlayerAction =
+   | { type: 'LOAD_CONTENT'; payload: string }
+   | { type: 'PLAY' }
+   | { type: 'PAUSE' }
+   | { type: 'SEEK'; payload: number }
+   | { type: 'SET_DURATION'; payload: number }
+   | { type: 'UPDATE_TIME'; payload: number }
+   | { type: 'UPDATE_BUFFER'; payload: number }
+   | { type: 'SET_VOLUME'; payload: number }
+   | { type: 'MUTE' }
+   | { type: 'UNMUTE' }
+   | { type: 'SET_PLAYBACK_RATE'; payload: number }
+   | { type: 'ENTER_FULLSCREEN' }
+   | { type: 'EXIT_FULLSCREEN' }
+   | { type: 'SET_QUALITY'; payload: PlayerState['quality'] }
+   | { type: 'LOADING_START' }
+   | { type: 'LOADING_END' }
+   | { type: 'ERROR'; payload: string }
+   | { type: 'RESET' };
+ 
+ // Define initial state
+ const initialState: PlayerState = {
+   currentContentId: null,
+   isPlaying: false,
+   duration: 0,
+   currentTime: 0,
+   buffered: 0,
+   volume: 1,
+   isMuted: false,
+   playbackRate: 1,
+   isFullscreen: false,
+   quality: 'auto',
+   isLoading: false,
+   error: null
+ };
+ 
+ // Create context
+ interface PlayerContextType {
+   state: PlayerState;
+   dispatch: React.Dispatch<PlayerAction>;
+   playerRef: React.RefObject<HTMLVideoElement>;
+   loadContent: (contentId: string) => void;
+   play: () => void;
+   pause: () => void;
+   togglePlay: () => void;
+   seek: (time: number) => void;
+   skipForward: (seconds?: number) => void;
+   skipBackward: (seconds?: number) => void;
+   setVolume: (volume: number) => void;
+   toggleMute: () => void;
+   setPlaybackRate: (rate: number) => void;
+   toggleFullscreen: () => void;
+   setQuality: (quality: PlayerState['quality']) => void;
+ }
+ 
+ const PlayerContext = createContext<PlayerContextType>({
+   state: initialState,
+   dispatch: () => null,
+   playerRef: { current: null },
+   loadContent: () => {},
+   play: () => {},
+   pause: () => {},
+   togglePlay: () => {},
+   seek: () => {},
+   skipForward: () => {},
+   skipBackward: () => {},
+   setVolume: () => {},
+   toggleMute: () => {},
+   setPlaybackRate: () => {},
+   toggleFullscreen: () => {},
+   setQuality: () => {}
+ });
+ 
+ // Create reducer
+ const playerReducer = (state: PlayerState, action: PlayerAction): PlayerState => {
+   switch (action.type) {
+     case 'LOAD_CONTENT':
+       return {
+         ...initialState,
+         currentContentId: action.payload,
+         isLoading: true
+       };
+     case 'PLAY':
+       return {
+         ...state,
+         isPlaying: true
+       };
+     case 'PAUSE':
+       return {
+         ...state,
+         isPlaying: false
+       };
+     case 'SEEK':
+       return {
+         ...state,
+         currentTime: action.payload
+       };
+     case 'SET_DURATION':
+       return {
+         ...state,
+         duration: action.payload
+       };
+     case 'UPDATE_TIME':
+       return {
+         ...state,
+         currentTime: action.payload
+       };
+     case 'UPDATE_BUFFER':
+       return {
+         ...state,
+         buffered: action.payload
+       };
+     case 'SET_VOLUME':
+       return {
+         ...state,
+         volume: action.payload,
+         isMuted: action.payload === 0
+       };
+     case 'MUTE':
+       return {
+         ...state,
+         isMuted: true
+       };
+     case 'UNMUTE':
+       return {
+         ...state,
+         isMuted: false
+       };
+     case 'SET_PLAYBACK_RATE':
+       return {
+         ...state,
+         playbackRate: action.payload
+       };
+     case 'ENTER_FULLSCREEN':
+       return {
+         ...state,
+         isFullscreen: true
+       };
+     case 'EXIT_FULLSCREEN':
+       return {
+         ...state,
+         isFullscreen: false
+       };
+     case 'SET_QUALITY':
+       return {
+         ...state,
+         quality: action.payload
+       };
+     case 'LOADING_START':
+       return {
+         ...state,
+         isLoading: true
+       };
+     case 'LOADING_END':
+       return {
+         ...state,
+         isLoading: false
+       };
+     case 'ERROR':
+       return {
+         ...state,
+         error: action.payload,
+         isPlaying: false,
+         isLoading: false
+       };
+     case 'RESET':
+       return initialState;
+     default:
+       return state;
+   }
+ };
+ 
+ // Create provider
+ interface PlayerProviderProps {
+   children: ReactNode;
+ }
+ 
+ export const PlayerProvider: React.FC<PlayerProviderProps> = ({ children }) => {
+   const [state, dispatch] = useReducer(playerReducer, initialState);
+   const playerRef = useRef<HTMLVideoElement>(null);
+   
+   // Load content
+   const loadContent = useCallback((contentId: string) => {
+     dispatch({ type: 'LOAD_CONTENT', payload: contentId });
+   }, []);
+   
+   // Play video
+   const play = useCallback(() => {
+     if (playerRef.current) {
+       playerRef.current.play()
+         .then(() => dispatch({ type: 'PLAY' }))
+         .catch(error => dispatch({ type: 'ERROR', payload: error.message }));
+     }
+   }, []);
+   
+   // Pause video
+   const pause = useCallback(() => {
+     if (playerRef.current) {
+       playerRef.current.pause();
+       dispatch({ type: 'PAUSE' });
+     }
+   }, []);
+   
+   // Toggle play/pause
+   const togglePlay = useCallback(() => {
+     if (state.isPlaying) {
+       pause();
+     } else {
+       play();
+     }
+   }, [state.isPlaying, play, pause]);
+   
+   // Seek to time
+   const seek = useCallback((time: number) => {
+     if (playerRef.current) {
+       playerRef.current.currentTime = Math.max(0, Math.min(time, state.duration));
+       dispatch({ type: 'SEEK', payload: playerRef.current.currentTime });
+     }
+   }, [state.duration]);
+   
+   // Skip forward
+   const skipForward = useCallback((seconds = 10) => {
+     seek(state.currentTime + seconds);
+   }, [state.currentTime, seek]);
+   
+   // Skip backward
+   const skipBackward = useCallback((seconds = 10) => {
+     seek(state.currentTime - seconds);
+   }, [state.currentTime, seek]);
+   
+   // Set volume
+   const setVolume = useCallback((volume: number) => {
+     if (playerRef.current) {
+       const clampedVolume = Math.max(0, Math.min(1, volume));
+       playerRef.current.volume = clampedVolume;
+       dispatch({ type: 'SET_VOLUME', payload: clampedVolume });
+     }
+   }, []);
+   
+   // Toggle mute
+   const toggleMute = useCallback(() => {
+     if (playerRef.current) {
+       if (state.isMuted) {
+         playerRef.current.muted = false;
+         dispatch({ type: 'UNMUTE' });
+       } else {
+         playerRef.current.muted = true;
+         dispatch({ type: 'MUTE' });
+       }
+     }
+   }, [state.isMuted]);
+   
+   // Set playback rate
+   const setPlaybackRate = useCallback((rate: number) => {
+     if (playerRef.current) {
+       playerRef.current.playbackRate = rate;
+       dispatch({ type: 'SET_PLAYBACK_RATE', payload: rate });
+     }
+   }, []);
+   
+   // Toggle fullscreen
+   const toggleFullscreen = useCallback(() => {
+     const videoElement = playerRef.current;
+     if (!videoElement) return;
+     
+     if (!state.isFullscreen) {
+       if (videoElement.requestFullscreen) {
+         videoElement.requestFullscreen()
+           .then(() => dispatch({ type: 'ENTER_FULLSCREEN' }))
+           .catch(error => console.error('Failed to enter fullscreen:', error));
+       }
+     } else {
+       if (document.exitFullscreen) {
+         document.exitFullscreen()
+           .then(() => dispatch({ type: 'EXIT_FULLSCREEN' }))
+           .catch(error => console.error('Failed to exit fullscreen:', error));
+       }
+     }
+   }, [state.isFullscreen]);
+   
+   // Set quality
+   const setQuality = useCallback((quality: PlayerState['quality']) => {
+     dispatch({ type: 'SET_QUALITY', payload: quality });
+     // In a real implementation, you would adjust the video source or use an API
+     // to change the quality of the stream
+   }, []);
+   
+   // Set up event listeners for the video element
+   useEffect(() => {
+     const video = playerRef.current;
+     if (!video) return;
+     
+     const handleTimeUpdate = () => {
+       dispatch({ type: 'UPDATE_TIME', payload: video.currentTime });
+     };
+     
+     const handleDurationChange = () => {
+       dispatch({ type: 'SET_DURATION', payload: video.duration });
+     };
+     
+     const handleProgress = () => {
+       if (video.buffered.length > 0) {
+         dispatch({ 
+           type: 'UPDATE_BUFFER', 
+           payload: video.buffered.end(video.buffered.length - 1) 
+         });
+       }
+     };
+     
+     const handlePlay = () => {
+       dispatch({ type: 'PLAY' });
+     };
+     
+     const handlePause = () => {
+       dispatch({ type: 'PAUSE' });
+     };
+     
+     const handleVolumeChange = () => {
+       dispatch({ type: 'SET_VOLUME', payload: video.volume });
+       if (video.muted) {
+         dispatch({ type: 'MUTE' });
+       } else {
+         dispatch({ type: 'UNMUTE' });
+       }
+     };
+     
+     const handleError = () => {
+       dispatch({ 
+         type: 'ERROR', 
+         payload: 'An error occurred while playing the video' 
+       });
+     };
+     
+     const handleLoadStart = () => {
+       dispatch({ type: 'LOADING_START' });
+     };
+     
+     const handleCanPlay = () => {
+       dispatch({ type: 'LOADING_END' });
+     };
+     
+     const handleFullscreenChange = () => {
+       if (document.fullscreenElement === video) {
+         dispatch({ type: 'ENTER_FULLSCREEN' });
+       } else {
+         dispatch({ type: 'EXIT_FULLSCREEN' });
+       }
+     };
+     
+     // Add event listeners
+     video.addEventListener('timeupdate', handleTimeUpdate);
+     video.addEventListener('durationchange', handleDurationChange);
+     video.addEventListener('progress', handleProgress);
+     video.addEventListener('play', handlePlay);
+     video.addEventListener('pause', handlePause);
+     video.addEventListener('volumechange', handleVolumeChange);
+     video.addEventListener('error', handleError);
+     video.addEventListener('loadstart', handleLoadStart);
+     video.addEventListener('canplay', handleCanPlay);
+     document.addEventListener('fullscreenchange', handleFullscreenChange);
+     
+     // Cleanup
+     return () => {
+       video.removeEventListener('timeupdate', handleTimeUpdate);
+       video.removeEventListener('durationchange', handleDurationChange);
+       video.removeEventListener('progress', handleProgress);
+       video.removeEventListener('play', handlePlay);
+       video.removeEventListener('pause', handlePause);
+       video.removeEventListener('volumechange', handleVolumeChange);
+       video.removeEventListener('error', handleError);
+       video.removeEventListener('loadstart', handleLoadStart);
+       video.removeEventListener('canplay', handleCanPlay);
+       document.removeEventListener('fullscreenchange', handleFullscreenChange);
+     };
+   }, []);
+   
+   // Save playback progress to localStorage when progress changes
+   useEffect(() => {
+     if (state.currentContentId && state.currentTime > 0) {
+       const progressData = JSON.parse(localStorage.getItem('videoProgress') || '{}');
+       progressData[state.currentContentId] = state.currentTime;
+       localStorage.setItem('videoProgress', JSON.stringify(progressData));
+     }
+   }, [state.currentContentId, state.currentTime]);
+   
+   // Load saved progress when content changes
+   useEffect(() => {
+     if (state.currentContentId) {
+       const progressData = JSON.parse(localStorage.getItem('videoProgress') || '{}');
+       const savedProgress = progressData[state.currentContentId];
+       if (savedProgress && playerRef.current) {
+         playerRef.current.currentTime = savedProgress;
+         dispatch({ type: 'UPDATE_TIME', payload: savedProgress });
+       }
+     }
+   }, [state.currentContentId]);
+   
+   // Context value
+   const contextValue: PlayerContextType = {
+     state,
+     dispatch,
+     playerRef,
+     loadContent,
+     play,
+     pause,
+     togglePlay,
+     seek,
+     skipForward,
+     skipBackward,
+     setVolume,
+     toggleMute,
+     setPlaybackRate,
+     toggleFullscreen,
+     setQuality
+   };
+   
+   return (
+     <PlayerContext.Provider value={contextValue}>
+       {children}
+     </PlayerContext.Provider>
+   );
+ };
+ 
+ export const usePlayerContext = () => useContext(PlayerContext); 
```

---

Let's fix the linter errors in PlayerContext.tsx related to the ref:

---

```diff
    state: PlayerState;
    dispatch: React.Dispatch<PlayerAction>;
-   playerRef: React.RefObject<HTMLVideoElement>;
+   playerRef: React.RefObject<HTMLVideoElement | null>;
    loadContent: (contentId: string) => void;
    play: () => void;
```

---

Now, let's create a hook for the app context:

---

```diff
- 
+ import { useAppContext as useAppContextInternal } from '../context/AppContext';
+ 
+ /**
+  * Custom hook for accessing the AppContext
+  * 
+  * This hook provides access to application-wide state and functions like:
+  * - dark mode toggling
+  * - loading state
+  * - online status
+  * - debug mode
+  * 
+  * @returns The AppContext value
+  */
+ export const useAppContext = () => {
+   const context = useAppContextInternal();
+   
+   if (!context) {
+     throw new Error('useAppContext must be used within an AppProvider');
+   }
+   
+   return context;
+ };
+ 
+ export default useAppContext; 
```

---

Let's create a hook for accessing the content context:

---

```diff
- 
+ import { useContentContext as useContentContextInternal } from '../context/ContentContext';
+ 
+ /**
+  * Custom hook for accessing the ContentContext
+  * 
+  * This hook provides access to content-related state and functions like:
+  * - content items and categories
+  * - favorite management
+  * - progress tracking
+  * - content fetching
+  * 
+  * @returns The ContentContext value
+  */
+ export const useContentContext = () => {
+   const context = useContentContextInternal();
+   
+   if (!context) {
+     throw new Error('useContentContext must be used within a ContentProvider');
+   }
+   
+   return context;
+ };
+ 
+ export default useContentContext; 
```

---

Let's create a hook for accessing the user context:

---

```diff
- 
+ import { useUserContext as useUserContextInternal } from '../context/UserContext';
+ 
+ /**
+  * Custom hook for accessing the UserContext
+  * 
+  * This hook provides access to user-related state and functions like:
+  * - authentication status
+  * - user profiles
+  * - preferences management 
+  * - profile switching
+  * 
+  * @returns The UserContext value
+  */
+ export const useUserContext = () => {
+   const context = useUserContextInternal();
+   
+   if (!context) {
+     throw new Error('useUserContext must be used within a UserProvider');
+   }
+   
+   return context;
+ };
+ 
+ export default useUserContext; 
```

---

Let's create a hook for accessing the player context:

---



---



---



---



---



---



---

