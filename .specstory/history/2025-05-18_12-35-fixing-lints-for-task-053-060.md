<!-- Generated by SpecStory -->

# Fixing Lints for Task 053-060 (2025-05-18 08:35:53)

_**User**_

@TASK-053-060.md systematically fix lints from this task 

---

_**Assistant**_



---

Let me first explore the project structure to identify the relevant files for linting fixes related to TASK-053-060.

---

Could not resolve URI: Error: Unable to resolve nonexistent file 'd:\Sanza-TV-App_QuickPoll_v1\src'

---

Let me check the root directory first to better understand the project structure.

---

<details>
            <summary>Listed current directory â€¢ **8** results</summary>
        
| Name |
|-------|
| ğŸ“ `StreamVibe` |
| ğŸ“ `tasks` |
| ğŸ“„ `TASK-LIST.md` |
| ğŸ“ `docs` |
| ğŸ“„ `README.md` |
| ğŸ“„ `TASK-TEMPLATE.md` |
| ğŸ“„ `.cursorindexingignore` |
| ğŸ“ `.specstory` |

</details>

---

Let me look at the StreamVibe directory which appears to be the main project directory:

---

<details>
            <summary>Listed directory StreamVibe â€¢ **16** results</summary>
        
| Name |
|-------|
| ğŸ“„ `package.json` |
| ğŸ“ `cypress` |
| ğŸ“„ `cypress.config.js` |
| ğŸ“ `node_modules` |
| ğŸ“„ `pnpm-lock.yaml` |
| ğŸ“ `src` |
| ğŸ“„ `jest.config.js` |
| ğŸ“„ `tsconfig.json` |
| ğŸ“ `public` |
| ğŸ“„ `vite.config.ts` |
| ğŸ“„ `index.html` |
| ğŸ“„ `README.md` |
| ğŸ“„ `tsconfig.app.json` |
| ğŸ“„ `tsconfig.node.json` |
| ğŸ“„ `eslint.config.js` |
| ğŸ“„ `.gitignore` |

</details>

---

Now let's look at the src directory to find the AI services mentioned in the task:

---

<details>
            <summary>Listed directory StreamVibe/src â€¢ **16** results</summary>
        
| Name |
|-------|
| ğŸ“ `services` |
| ğŸ“ `tests` |
| ğŸ“ `hooks` |
| ğŸ“ `components` |
| ğŸ“ `pages` |
| ğŸ“ `utils` |
| ğŸ“ `types` |
| ğŸ“ `context` |
| ğŸ“„ `App.tsx` |
| ğŸ“ `navigation` |
| ğŸ“ `styles` |
| ğŸ“„ `main.tsx` |
| ğŸ“ `assets` |
| ğŸ“„ `vite-env.d.ts` |
| ğŸ“„ `index.css` |
| ğŸ“„ `App.css` |

</details>

---

Let's check the AI services directory:

---

<details>
            <summary>Listed directory StreamVibe/src/services/ai â€¢ **6** results</summary>
        
| Name |
|-------|
| ğŸ“ `__tests__` |
| ğŸ“„ `DescriptionGenerator.ts` |
| ğŸ“„ `ContentTagger.ts` |
| ğŸ“„ `index.ts` |
| ğŸ“„ `MoodRecommender.ts` |
| ğŸ“„ `PersonalizedGreeting.ts` |

</details>

---

Let's also check if the performance optimization services that were mentioned in the task have been implemented:

---

<details>
            <summary>Listed directory StreamVibe/src/services â€¢ **14** results</summary>
        
| Name |
|-------|
| ğŸ“„ `PerformanceOptimization.ts` |
| ğŸ“„ `AIServiceOptimizer.ts` |
| ğŸ“ `ai` |
| ğŸ“ `api` |
| ğŸ“„ `InteractiveService.ts` |
| ğŸ“„ `PlaybackService.ts` |
| ğŸ“„ `RecommendationService.ts` |
| ğŸ“„ `PreferencesService.ts` |
| ğŸ“„ `OpenAIService.ts` |
| ğŸ“ `SoundEffects` |
| ğŸ“„ `senza-sdk.ts` |
| ğŸ“„ `app-lifecycle.ts` |
| ğŸ“„ `ContentService.ts` |
| ğŸ“„ `navigation.ts` |

</details>

---

Now let's check if there's an ESLint configuration file that might show us what rules we need to fix:

---

Read file: StreamVibe/eslint.config.js

---

Let's run a lint check to see what issues need to be fixed:

---

```bash
cd StreamVibe && pnpm run lint
```

```
At line:1 char:15
+ cd StreamVibe && pnpm run lint
+               ~~
The token '&&' is not a valid statement separator in this version.
    + CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordExce
ption
    + FullyQualifiedErrorId : InvalidEndOfLine

```

---

It seems Windows PowerShell doesn't support the `&&` operator. Let's try running the commands separately:

---

```bash
cd StreamVibe
```

```
PS D:\Sanza-TV-App_QuickPoll_v1> cd StreamVibe
PS D:\Sanza-TV-App_QuickPoll_v1\StreamVibe>
```

---

```bash
pnpm run lint
```

```

> streamvibe@0.0.0 lint D:\Sanza-TV-App_QuickPoll_v1\StreamVibe
> eslint .


D:\Sanza-TV-App_QuickPoll_v1\StreamVibe\src\services\AIServiceOptimizer.ts
   38:38  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  262:48  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  280:38  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  314:24  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

D:\Sanza-TV-App_QuickPoll_v1\StreamVibe\src\services\PerformanceOptimization.ts
   79:13  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
   80:22  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
   81:22  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
   87:35  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  158:14  error  'error' is defined but never used         @typescript-eslint/no-unused-vars
  234:54  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  287:13  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  396:50  error  'params' is defined but never used        @typescript-eslint/no-unused-vars
  396:58  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  396:72  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

D:\Sanza-TV-App_QuickPoll_v1\StreamVibe\src\services\ai\__tests__\ContentTagger.test.ts
  18:26  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  19:27  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

D:\Sanza-TV-App_QuickPoll_v1\StreamVibe\src\services\ai\__tests__\PersonalizedGreeting.test.ts
   23:26  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
   24:31  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
   25:27  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  226:12  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  248:12  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

D:\Sanza-TV-App_QuickPoll_v1\StreamVibe\src\tests\utils\TestUtils.js

âœ– 22 problems (22 errors, 0 warnings)

â€‰ELIFECYCLEâ€‰ Command failed with exit code 1.
PS D:\Sanza-TV-App_QuickPoll_v1\StreamVibe>
```

---

Great! Now I can see the linting issues we need to fix. Let's start by fixing them one by one. The main problems are:

1. Usage of `any` type which is against TypeScript best practices
2. Unused variables

Let's start with the AIServiceOptimizer.ts file:

---

Read file: StreamVibe/src/services/AIServiceOptimizer.ts

---

Let me check the rest of the AIServiceOptimizer.ts file:

---

Read file: StreamVibe/src/services/AIServiceOptimizer.ts

---

Now let's check the PerformanceOptimization.ts file:

---

Read file: StreamVibe/src/services/PerformanceOptimization.ts

---

Let's also check the test files to fix the remaining lint issues:

---

Read file: StreamVibe/src/services/ai/__tests__/ContentTagger.test.ts

---

Read file: StreamVibe/src/services/ai/__tests__/PersonalizedGreeting.test.ts

---

Let's finish looking at PersonalizedGreeting.test.ts:

---

Read file: StreamVibe/src/services/ai/__tests__/PersonalizedGreeting.test.ts

---

Now I understand the linting issues. Let's fix each file one by one:

1. First, let's fix the AIServiceOptimizer.ts:

---

```diff
    forceRefresh?: boolean;
  }
+ 
+ // Cache item interface
+ interface CacheItem<T> {
+   data: T;
+   expires: number;
+   accessCount: number;
+ }
  
  class AIServiceOptimizer {
    private static instance: AIServiceOptimizer;
    private performanceService: PerformanceOptimization;
    private openAIService: OpenAIService;
-   private cache: Map<string, { data: any; expires: number; accessCount: number }> = new Map();
+   private cache: Map<string, CacheItem<unknown>> = new Map();
    private readonly DEFAULT_TTL = 60 * 60 * 1000; // 1 hour
    private readonly DEFAULT_TIMEOUT = 5000; // 5 seconds
```

```diff
        if (cachingEnabled && !forceRefresh) {
          const cacheKey = cacheConfig.key;
-         const cachedItem = this.cache.get(cacheKey);
+         const cachedItem = this.cache.get(cacheKey) as CacheItem<T> | undefined;
          
          if (cachedItem && cachedItem.expires > Date.now()) {
```

```diff
          // Try to find any cached item, even expired ones
          const cacheKey = cacheConfig.key;
-         const cachedItem = this.cache.get(cacheKey);
+         const cachedItem = this.cache.get(cacheKey) as CacheItem<T> | undefined;
          
          if (cachedItem) {
```

```diff
      // Check if already cached
      const cacheKey = cacheConfig.key;
-     const cachedItem = this.cache.get(cacheKey);
+     const cachedItem = this.cache.get(cacheKey) as CacheItem<T> | undefined;
      if (cachedItem && cachedItem.expires > Date.now()) {
        return; // Already in cache, no need to prefetch
```

```diff
          this.cache = new Map();
          for (const [key, value] of Object.entries(parsedData)) {
-           this.cache.set(key, value as { data: any; expires: number; accessCount: number });
+           this.cache.set(key, value as CacheItem<unknown>);
          }
          
```

```diff
      try {
        // Convert Map to object for storage
-       const cacheObj: Record<string, any> = {};
+       const cacheObj: Record<string, CacheItem<unknown>> = {};
        this.cache.forEach((value, key) => {
          cacheObj[key] = value;
```

```diff
     * Get performance metrics for AI services
     */
-   public getMetrics(): any {
+   public getMetrics(): Record<string, unknown> {
      return {
        ...this.performanceService.getPerformanceMetrics(),
```

---

2. Now let's fix the PerformanceOptimization.ts:

---

Read file: StreamVibe/src/services/PerformanceOptimization.ts

---

Now let's fix the PerformanceOptimization.ts file:

---

```diff
   */
  
+ // Type for performance settings
+ interface PerformanceSettings {
+   // Cache settings
+   cacheEnabled: boolean;
+   cacheTTL: number;
+   maxCacheItems: number;
+   prioritizeCacheForSlowConnections: boolean;
+   
+   // API call optimization
+   batchingEnabled: boolean;
+   maxBatchSize: number;
+   batchingWindow: number;
+   
+   // Network condition detection
+   autoDetectNetworkConditions: boolean;
+   networkCheckInterval: number;
+   
+   // Request priority
+   deprioritizeBackgroundRequests: boolean;
+   
+   // Performance metrics
+   collectMetrics: boolean;
+   metricsReportingInterval: number;
+   
+   // Throttling
+   maxRequestsPerMinute: number;
+   
+   // Offline support
+   offlineModeEnabled: boolean;
+   preloadOfflineFallbackData: boolean;
+   
+   // Prefetching
+   contentPrefetchingEnabled: boolean;
+   prefetchThreshold: number;
+   
+   // Progressive loading
+   progressiveLoadingEnabled: boolean;
+   initialLoadTimeLimit: number;
+ }
+ 
+ // Type for performance metrics
+ interface PerformanceMetrics {
+   apiCalls: number;
+   cachedResponses: number;
+   totalResponseTime: number;
+   averageResponseTime: number;
+   networkErrorCount: number;
+   slowestEndpoint: string;
+   slowestResponseTime: number;
+   requestsPerEndpoint: Record<string, number>;
+   cacheHitRate: number;
+   offlineModeActivations: number;
+ }
+ 
+ // Type for cache statistics
+ interface CacheStats {
+   totalSize: number;
+   hitCount: number;
+   missCount: number;
+   entryCount: number;
+   evictionCount: number;
+ }
+ 
+ // Type for queued request
+ interface QueuedRequest<T> {
+   id: string;
+   endpoint: string;
+   params: Record<string, unknown>;
+   resolve: (value: T) => void;
+   reject: (reason: unknown) => void;
+   priority: 'high' | 'normal' | 'low';
+   timestamp: number;
+ }
+ 
  class PerformanceOptimization {
    private static instance: PerformanceOptimization;
    
    // Default settings
-   private settings = {
+   private settings: PerformanceSettings = {
      // Cache settings
      cacheEnabled: true,
```

```diff
    
    // Performance metrics
-   private metrics = {
+   private metrics: PerformanceMetrics = {
      apiCalls: 0,
      cachedResponses: 0,
```

```diff
      slowestEndpoint: '',
      slowestResponseTime: 0,
-     requestsPerEndpoint: {} as Record<string, number>,
+     requestsPerEndpoint: {},
      cacheHitRate: 0,
      offlineModeActivations: 0,
    };
    
    // Cache stats
-   private cacheStats = {
+   private cacheStats: CacheStats = {
      totalSize: 0,
      hitCount: 0,
```

```diff
    
    // Request queue for batching
-   private requestQueue: Array<{
-     id: string;
-     endpoint: string;
-     params: any;
-     resolve: (value: any) => void;
-     reject: (reason: any) => void;
-     priority: 'high' | 'normal' | 'low';
-     timestamp: number;
-   }> = [];
+   private requestQueue: Array<QueuedRequest<unknown>> = [];
    
    // Queue processing timeout
-   private queueProcessingTimeout: any = null;
+   private queueProcessingTimeout: ReturnType<typeof setTimeout> | null = null;
    
    private constructor() {
```

```diff
     * Get current performance metrics
     */
-   public getPerformanceMetrics() {
+   public getPerformanceMetrics(): Record<string, unknown> {
      return {
        ...this.metrics,
```

```diff
     * Get settings for a specific service
     */
-   public getSettingsForService(serviceName: string): any {
+   public getSettingsForService(serviceName: string): PerformanceSettings {
      // Service-specific optimizations could be defined here
      switch (serviceName) {
```

```diff
     * Update settings
     */
-   public updateSettings(newSettings: Partial<typeof this.settings>): void {
+   public updateSettings(newSettings: Partial<PerformanceSettings>): void {
      this.settings = { ...this.settings, ...newSettings };
    }
```

```diff
    public queueRequest<T>(
      endpoint: string, 
-     params: any, 
+     params: Record<string, unknown>, 
      priority: 'high' | 'normal' | 'low' = 'normal'
    ): Promise<T> {
```

```diff
          // Just execute high priority immediately
          this.executeRequest(endpoint, params)
-           .then(resolve)
+           .then(result => resolve(result as T))
            .catch(reject);
          return;
```

```diff
          endpoint,
          params,
-         resolve,
+         resolve: resolve as (value: unknown) => void,
          reject,
          priority,
```

```diff
      
      // Clear the timeout
+     if (this.queueProcessingTimeout) {
        clearTimeout(this.queueProcessingTimeout);
        this.queueProcessingTimeout = null;
+     }
      
      // Sort by priority and timestamp
```

```diff
     * Execute a single API request
     */
-   private async executeRequest(endpoint: string, params: any): Promise<any> {
+   private async executeRequest(endpoint: string, params: Record<string, unknown>): Promise<unknown> {
      // This is a placeholder - in a real app, you'd implement the actual API call
      // For now, just simulating a response
```

---

3. Now let's fix the ContentTagger.test.ts:

---

```diff
  import { mockContentItems } from '../../../tests/mocks/MockData';
  import { setupLocalStorageMock } from '../../../tests/utils/TestUtils';
+ 
+ // Mock types for the services
+ interface MockOpenAIService {
+   hasApiKey: jest.Mock;
+   generateChatCompletion: jest.Mock;
+ }
+ 
+ interface MockContentService {
+   getContentById: jest.Mock;
+   getAllContent: jest.Mock;
+ }
  
  // Mock dependencies
```

```diff
  describe('ContentTagger', () => {
    let contentTagger: ContentTagger;
-   let mockOpenAIService: any;
-   let mockContentService: any;
+   let mockOpenAIService: MockOpenAIService;
+   let mockContentService: MockContentService;
    
    beforeEach(() => {
```

---

4. Finally, let's fix the PersonalizedGreeting.test.ts:

---

```diff
  import { mockContentItems } from '../../../tests/mocks/MockData';
  import { setupLocalStorageMock } from '../../../tests/utils/TestUtils';
+ 
+ // Mock types for the services
+ interface MockOpenAIService {
+   hasApiKey: jest.Mock;
+   generateChatCompletion: jest.Mock;
+ }
+ 
+ interface MockPreferencesService {
+   getActiveProfile: jest.Mock;
+   getUserPreferenceData: jest.Mock;
+ }
+ 
+ interface MockContentService {
+   getRecentlyWatched: jest.Mock;
+   getAllContent: jest.Mock;
+ }
+ 
+ // Type for the global Date mock
+ interface MockDateClass {
+   new(): Date;
+   prototype: Date;
+   getHours(): number;
+ }
  
  // Mock dependencies
```

```diff
  describe('PersonalizedGreeting', () => {
    let personalizedGreeting: PersonalizedGreeting;
-   let mockOpenAIService: any;
-   let mockPreferencesService: any;
-   let mockContentService: any;
+   let mockOpenAIService: MockOpenAIService;
+   let mockPreferencesService: MockPreferencesService;
+   let mockContentService: MockContentService;
    
    beforeEach(() => {
```

```diff
            return 8; // 8 AM
          }
-       } as any;
+       } as MockDateClass;
        
        // Set up user profile
```

```diff
            return 14; // 2 PM
          }
-       } as any;
+       } as MockDateClass;
        
        // Reset cache
```

---

Let's run the lint check again to see how many issues remain:

---

```bash
pnpm run lint
```

```
PS D:\Sanza-TV-App_QuickPoll_v1\StreamVibe> pnpm run lint

> streamvibe@0.0.0 lint D:\Sanza-TV-App_QuickPoll_v1\StreamVibe


D:\Sanza-TV-App_QuickPoll_v1\StreamVibe\src\services\PerformanceOptimization.ts
  224:14  error  'error' is defined but never used   @typescript-eslint/no-unused-vars
  464:50  error  'params' is defined but never used  @typescript-eslint/no-unused-vars

  15:7  error  Parsing error: Unexpected token <

âœ– 3 problems (3 errors, 0 warnings)

â€‰ELIFECYCLEâ€‰ Command failed with exit code 1.
PS D:\Sanza-TV-App_QuickPoll_v1\StreamVibe>
```

---

We've made good progress! We still have two issues in PerformanceOptimization.ts:

1. Unused 'error' variable
2. Unused 'params' variable

Let's fix these:

---

```diff
      return { success: true, data: `Response from ${endpoint}` };
    }
+   
+   /**
+    * Save cache to storage
+    */
+   private saveCacheToStorage(): void {
+     try {
+       // Convert Map to object for storage
+       const cacheObj: Record<string, CacheItem<unknown>> = {};
+       this.cache.forEach((value, key) => {
+         cacheObj[key] = value;
+       });
+       
+       localStorage.setItem('ai_optimizer_cache', JSON.stringify(cacheObj));
+     } catch (_error) {
+       console.error('Error saving cache to storage');
+     }
+   }
    
    /**
```

---

I apologize for the issues. Let's fix the correct section in the PerformanceOptimization.ts file:

---

Model provided invalid arguments to read file tool.

---

Read file: StreamVibe/src/services/PerformanceOptimization.ts

---



---



---



---



---



---



---

_**User**_

complete lint 

---

_**Assistant**_



---

